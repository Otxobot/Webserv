Archivos CGI:
  -Archivo cgiscript.cpp:
    #!/usr/bin/env python3
import os
import sys
import traceback
import cgi
# Función para manejar errores
def handle_error():
    print("Content-Type: text/html")
    print()
    print("<html>")
    print("<head>")
    print("<title>Error</title>")
    print("</head>")
    print("<body>")
    print("<h1>Error en el script CGI</h1>")
    print("<p>Ocurrió un error en la ejecución del script CGI.</p>")
    print("<h2>Traceback:</h2>")
    print("<pre>")
    traceback.print_exc(file=sys.stdout)
    print("</pre>")
    print("</body>")
    print("</html>")
try:
    # Obtiene los parámetros de la solicitud
    form = cgi.FieldStorage()
    # Genera la respuesta HTTP
    print("Content-Type: text/html")    # Indica el tipo de contenido
    print()                             # Línea en blanco para terminar los encabezados
    print("<html>")
    print("<head>")
    print("<title>CGI Script</title>")
    print("</head>")
    print("<body>")
    print("<h1>Hello, CGI!</h1>")
    print("<p>Este es un script CGI ejecutado desde el servidor web.</p>")
    # Mostrar los parámetros recibidos
    print("<h2>Parámetros recibidos:</h2>")
    print("<ul>")
    for key in form.keys():
        print(f"<li>{key}: {form.getvalue(key)}</li>")
    print("</ul>")
    print("</body>")
    print("</html>")
except Exception as e:
    handle_error()

    -Archivo cgi.cpp:
#include "cgi.hpp"
std::string int_to_string(int value) {
    std::stringstream ss;
    ss << value;
    return ss.str();
}
std::string runCGI(Request& _request, const std::string& root, const std::string& cgi_path) {
    char const *argv[3];
    int Ifd[2];
    pid_t pid;
    std::string content;
    extern char **environ;
    // Establecer variables de entorno
    setenv("GATEWAY_INTERFACE", "CGI/1.1", 1);
    setenv("SERVER_PROTOCOL", "HTTP/1.1", 1);
    setenv("SERVER_PORT", int_to_string(_request.getPort()).c_str(), 1);
    setenv("REQUEST_METHOD", _request.getMethod().c_str(), 1);
    setenv("SERVER_NAME", "webserv", 1);
    setenv("REDIRECT_STATUS", "1", 1);
    setenv("PATH_INFO", (root + _request.getTarget()).c_str(), 1);
    setenv("SCRIPT_FILENAME", (root + _request.getTarget()).c_str(), 1);
    if (!_request.getReqValue("Cookie").empty()) {
        setenv("HTTP_COOKIE", _request.getReqValue("Cookie").c_str(), 1);
    }
    if (_request.getMethod() == "GET") {
        setenv("QUERY_STRING", _request.getQueryString().c_str(), 1);
        setenv("CONTENT_LENGTH", "0", 1);
    }
    // Crear pipe
    if (pipe(Ifd)) {
        perror("[CGI ERROR] PIPE");
        return "";
    }
    // Crear proceso hijo
    pid = fork();
    if (pid < 0) {
        perror("[CGI ERROR] FORK");
        return "";
    }
    if (pid == 0) { // Proceso hijo
        close(Ifd[0]);
        dup2(Ifd[1], 1); // Redirigir stdout al pipe
        close(Ifd[1]);
        argv[0] = cgi_path.c_str();
        argv[1] = (root + _request.getTarget()).c_str();
        argv[2] = NULL;
        if (execve(argv[0], (char* const*)argv, environ) == -1) {
            perror("Error: Execve Can't run");
            exit(EXIT_FAILURE);
        }
    } else { // Proceso padre
        close(Ifd[1]);
        int ret;
        char buffer[1024];
        while ((ret = read(Ifd[0], buffer, sizeof(buffer) - 1)) > 0) {
            buffer[ret] = '\0';
            content += buffer;
        }
        close(Ifd[0]);
        waitpid(pid, NULL, 0);
    }
    return content;
}

  -Archivo cgi.hpp:
#ifndef CGI_HPP
#define CGI_HPP

#include <iostream>
#include <string>
#include <cstring>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <vector>
#include <map>
#include <sstream>
#include "../Webserv.hpp"

std::string runCGI(Request& _request, const std::string& root, const std::string& cgi_path);

#endif

Archivos de Configuracion:
  -Archivo Config.cpp:
#include "Config.hpp"
#include "Location.hpp"
#include "../server/Server.hpp"

class Config;

Config::Config()
{
	//Constructor Default
	_servername = "";
	_listen = "";
	_root = "";
	_file = "";
	_autoindex = false;
	_index = 0;
	_port = 0;
	_host = "";
	_client_max_body_size = 0;
}

Config::~Config()
{
	//Destructor Default
	
}

std::vector<Config> Config::parseConfig(std::string configFile)
{
	std::ifstream file(configFile.c_str());
	std::vector<Config> serversConfig;

	if (!file.is_open())
	{
		std::cout << "no se ha abierto bien el archivo" << std::endl;
	}

	std::string line;
	int contador = 0;
	while (std::getline(file, line))
	{
		if (line.find("server:") != std::string::npos)
		{
			contador++;
		}
	}
	file.clear();
	file.seekg(0, std::ios::beg); //Reiniciar el puntero del archivo para leerlo desde el principio
	int location_counter = 0;
	std::string line1;
	while (std::getline(file, line1))
	{
		if (line1.find("location:") != std::string::npos)
		{
			location_counter++;
		}
	}
	serversConfig = parseServers(file, contador);
	return (serversConfig);
}

std::vector<Config> Config::parseServers(std::ifstream &file, int contador)
{
	//Aqui hay que parsear todos los servidores y sus locations
	std::vector<Config>	_serversConfig;
	_serversConfig.resize(contador);

	file.clear();
	file.seekg(0, std::ios::beg);

	std::string line;
	std::string line_sin_comillas;
	int i = 0;
	_serversConfig[i]._index = i;
	std::getline(file, line);
	while (std::getline(file, line))
	{
		while (line.find("location:") != std::string::npos)
		{
			line_sin_comillas = this->trim_comillas(line.substr(12));
			_serversConfig[i]._locations[line_sin_comillas] = this->parseLocation(file, line);

		}
		if (line.find("server:") != std::string::npos)
		{
			i++;
			_serversConfig[i]._index = i;
			continue;
		}
		if (line.find("servername:") != std::string::npos)
		{
			_serversConfig[i]._servername = trim_comillas(line.substr(14));
		}
		if (line.find("root:") != std::string::npos)
		{
			_serversConfig[i]._root = trim_comillas(line.substr(8));
		}
		if (line.find("listen:") != std::string::npos)
		{
			_serversConfig[i]._listen = trim_comillas(line.substr(10));
			std::string listen = line.substr(10);
			size_t colonPos = listen.find(":");
			std::string host = listen.substr(0, colonPos);
			if (host.empty())
				_serversConfig[i]._host = "ANY";
			else
				_serversConfig[i]._host = host;
			std::string port_str = listen.substr(colonPos + 1);
    		int port = atoi(port_str.c_str());
			_serversConfig[i]._port = port;
			_serversConfig[i]._ports.push_back(port);
		}
		if (line.find("buffer_size: ") != std::string::npos)
        {
			std::string line_to_num = line.substr(15);
			int buffer_size = std::atoi(line_to_num.c_str());
			_serversConfig[i]._buffer_size = buffer_size;
        }
	}
	return (_serversConfig);
}

Location Config::parseLocation(std::ifstream &file, std::string &line)
{
    Location loc;
    while (std::getline(file, line))
    {
        if (line.find("location:") != std::string::npos || line.find("server:") != std::string::npos)
        {
		
            break;
        }
        if (line.find("allow: ") != std::string::npos)
        {
            if (line.substr(12).find("GET") != std::string::npos)
            {
                loc.setAllowGET(true);
            }
            if (line.substr(12).find("POST") != std::string::npos)
            {
                loc.setAllowPOST(true);
            }
            if (line.substr(12).find("DELETE") != std::string::npos)
            {
                loc.setAllowDELETE(true);
            }
        }
        if (line.find("file: ") != std::string::npos)
        {
            loc.setFile(trim_comillas(line.substr(10)));
        }
        if (line.find("redirect: ") != std::string::npos)
        {
            loc.setRedirect(trim_comillas(line.substr(14)));
        }
        if (line.find("root: ") != std::string::npos)
        {
            loc.setRoot(trim_comillas(line.substr(10)));
        }
        if (line.find("autoindex: ") != std::string::npos)
        {
            line.substr(14) == "on" ? loc.setAutoindex(true) : loc.setAutoindex(false);
        }
        if (line.find("handle_delete: ") != std::string::npos)
        {
            loc.setHandleDelete(trim_comillas(line.substr(19)));
        }
        if (line.find("handle_post: ") != std::string::npos)
        {
            loc.setHandlePost(trim_comillas(line.substr(17)));
        }
        if (line.find("error_page: ") != std::string::npos)
        {
            loc.setErrorPage(trim_comillas(line.substr(16)));
        }
        if (line.find("cgi: ") != std::string::npos)
        {
            loc.setCgi(trim_comillas(line.substr(9)));
        }
        if (line.find("upload: ") != std::string::npos)
        {
            loc.setUpload(trim_comillas(line.substr(12)));
        }
    }
    return (loc);
}

std::string Config::trim_comillas(const std::string& line) {
    std::string line_sin_espacios = line;

    size_t first_non_space = line_sin_espacios.find_first_not_of(" \t");
    if (first_non_space != std::string::npos && line_sin_espacios[first_non_space] == '"')
        line_sin_espacios.erase(0, first_non_space);

    while (!line_sin_espacios.empty() && line_sin_espacios[0] == '"')
        line_sin_espacios.erase(0, 1);

    size_t last_non_space = line_sin_espacios.find_last_not_of(" \t");
    if (last_non_space != std::string::npos && line_sin_espacios[last_non_space] == '"')
        line_sin_espacios.erase(last_non_space + 1);

    while (!line_sin_espacios.empty() && line_sin_espacios[line_sin_espacios.length() - 1] == '"')
        line_sin_espacios.erase(line_sin_espacios.length() - 1);

    return line_sin_espacios;
}

std::vector<int>  Config::getPorts()
{
    return this->_ports;
}

int Config::getPort()
{
	return this->_port;
}

std::string    Config::getHost()
{
    return (this->_host);
}

int Config::getIndex()
{
	return this->_index;
}

  -Archivo Config.hpp:
#ifndef CONFIG_HPP
#define CONFIG_HPP

//#include "../Webserv.hpp"
#include "../server/Server.hpp"
#include "../request/Request.hpp"
#include "./Location.hpp"
#include <string>
#include <fstream>
#include <vector>
#include <map>

class Location;

class Config
{
	private:
		int									_index;
		int									_port; //uint16_t
		std::vector<int> 					_ports;
		std::string									_host; //in_addr_t
		std::string							_servername;
		std::string							_root;
		std::string							_listen;
		std::string							_file;
		bool								_autoindex;
		std::map<int, std::string>			_errorpage;
		unsigned long						_client_max_body_size;
		int									_buffer_size;
	public:
		std::map<std::string, Location>		_locations;
		Config();
		~Config();

		std::vector<Config>		parseConfig(std::string configFile);
		std::vector<Config>		parseServers(std::ifstream &file, int contador);
		Location				parseLocation(std::ifstream &file, std::string &line);
		std::string 			trim_comillas(const std::string& line);
		std::vector<int>     	getPorts();
		int 					getPort();
		std::string 			getHost();
		int						getIndex();
		//std::map<std::string, Location>	getLocations();
};

#endif

  -Archivo Location.cpp:
#include "Location.hpp"

Location::Location()
{
	//Constructor Default
	_allowGET = false;
	_allowPOST = false;
	_allowDELETE = false;
	_file = "";
	_redirect = "";
	_root = "";
	_autoindex = false;
	_handle_delete = "";
	_handle_post = "";
	_error_page = "";
	_cgi = "";
	_upload = "";
	_buffer_size = 0;
}

Location::Location(const Location &other)
{
	//Constructor Copy
	_allowGET = other._allowGET;
	_allowPOST = other._allowPOST;
	_allowDELETE = other._allowDELETE;
	_file = other._file;
	_redirect = other._redirect;
	_root = other._root;
	_autoindex = other._autoindex;
	_handle_delete = other._handle_delete;
	_handle_post = other._handle_post;
	_error_page = other._error_page;
	_cgi = other._cgi;
	_upload = other._upload;
	_buffer_size = other._buffer_size;
}

Location::~Location()
{
	//Destructor Default
}

Location & Location::operator=(Location const &rhs)
{
	//Operator de asignacion
	if (this != &rhs)
	{
		_allowGET = rhs._allowGET;
		_allowPOST = rhs._allowPOST;
		_allowDELETE = rhs._allowDELETE;
		_file = rhs._file;
		_redirect = rhs._redirect;
		_root = rhs._root;
		_autoindex = rhs._autoindex;
		_handle_delete = rhs._handle_delete;
		_handle_post = rhs._handle_post;
		_error_page = rhs._error_page;
		_cgi = rhs._cgi;
		_upload = rhs._upload;
		_buffer_size = rhs._buffer_size;
	}
	return (*this);
}

void Location::setAllowGET(bool allowGET)
{
	_allowGET = allowGET;
	//std::cout << "Allow GET: " << _allowGET << std::endl;
}

void Location::setAllowPOST(bool allowPOST)
{
	_allowPOST = allowPOST;
	//std::cout << "Allow POST: " << _allowPOST << std::endl;
}

void Location::setAllowDELETE(bool allowDELETE)
{
	_allowDELETE = allowDELETE;
	//std::cout << "Allow DELETE:" << _allowDELETE << std::endl;
}

void Location::setFile(std::string file)
{
	_file = file;
	//std::cout << "File:" << _file << std::endl;
}

void Location::setRedirect(std::string redirect)
{
	_redirect = redirect;
	//std::cout << "Redirect:" << _redirect << std::endl;
}

void Location::setRoot(std::string root)
{
	_root = root;
	//std::cout << "Root:" << _root << std::endl;
}

void Location::setAutoindex(bool autoindex)
{
	_autoindex = autoindex;
	//std::cout << "Autoindex:" << _autoindex << std::endl;
}

void Location::setHandleDelete(std::string handle_delete)
{
	_handle_delete = handle_delete;
	//std::cout << "Handle Delete:" << _handle_delete << std::endl;
}

void Location::setHandlePost(std::string handle_post)
{
	_handle_post = handle_post;
	//std::cout << "Handle Post:" << _handle_post << std::endl;
}

void Location::setErrorPage(std::string error_page)
{
	_error_page = error_page;
	//std::cout << "Error Page:" << _error_page << std::endl;
}

void Location::setCgi(std::string cgi)
{
	_cgi = cgi;
	//std::cout << "Cgi:" << _cgi << std::endl;
}

void Location::setUpload(std::string upload)
{
	_upload = upload;
	//std::cout << "Upload:" << _upload << std::endl;
}

void Location::setBufferSize(int buffer_size)
{
	_buffer_size = buffer_size;
	//std::cout << "Buffer Size: " << _buffer_size << std::endl;
}

  -Archivo Location.hpp:
#ifndef LOCATION_HPP
#define LOCATION_HPP

#include "../Webserv.hpp"
#include "../request/Request.hpp"
#include "Config.hpp"
#include <string>
#include <vector>

class Location
{
	private:
		std::string		location_path;
		//int					_index;
		bool			_allowGET;
		bool			_allowPOST;
		bool			_allowDELETE;
		std::string					_redirect;
		std::string					_root;
		bool						_autoindex;
		std::string					_handle_delete;
		std::string					_handle_post;
		std::string					_error_page;
		std::string					_cgi;
		std::string					_upload;
		int							_buffer_size;
	public:
		std::string					_file;
		Location();
		Location(const Location &other);
		Location &operator=(const Location &rhs);
		~Location();
		void setAllowGET(bool allowGET);
		void setAllowPOST(bool allowPOST);
		void setAllowDELETE(bool allowDELETE);
		void setFile(std::string file);
		void setRedirect(std::string redirect);
		void setRoot(std::string root);
		void setAutoindex(bool autoindex);
		void setHandleDelete(std::string handle_delete);
		void setHandlePost(std::string handle_post);
		void setErrorPage(std::string error_page);
		void setCgi(std::string cgi);
		void setUpload(std::string upload);
		void setBufferSize(int buffer_size);
};

#endif

Archivos de Request:
  -Archivo Request.cpp:
#include "Request.hpp"

Request::Request() : target(""), queryUrl(""), url(""), _statusCode(200)
{
	this->headers.clear();
}

Request::~Request()
{
    //Default destructor
	this->target.clear();
	this->url.clear();
}

void	Request::printRequestInformation()
{
	std::cout << "Method: " << this->Method << std::endl;
	std::cout << "Target: " << this->target << std::endl;
	std::cout << "Protocol: " << this->protocol << std::endl; 
	for (std::map<std::string, std::string>::iterator it = this->headers.begin(); it != this->headers.end(); it++)
	{
		if (!it->second.empty())
			std::cout << "" << it->first << ": " << it->second  << std::endl;
	}
	if (!this->queryUrl.empty())
		std::cout << "Query: " << this->queryUrl << std::endl;
	if (!this->url.empty())
		std::cout << "Url: " << this->url << std::endl;
	std::cout << this->body << std::endl;
}

int Request::Request_start(std::string request)
{
    int status_code = 0;
	this->request = request;
	std::cout << this->request << std::endl;
	if ((status_code = this->request_line()) || (status_code = this->request_headers()) || (status_code = this->request_body()))
		{
			this->_statusCode = status_code;
			return (status_code);
		}
	std::cout <<"+++++++++++++++++++++++++++++ Request ++++++++++++++++++++++++++++++++" << std::endl;
	//printRequestInformation();
	return 0;
}

int		Request::request_line()
{
	std::string Method;
	if (request.find("\r\n") != std::string::npos)
	{
		std::string tmp = request.substr(0, request.find(' '));

		if (tmp == "GET" || tmp == "POST" || tmp == "DELETE")
		{
			this->Method = tmp;
			request.erase(0, this->Method.length() + 1);
		}
		else
			return NOT_IMPLEMENTED;
		if (request.find(' ') == 0)
			return BAD_REQUEST;
		tmp = request.substr(0, request.find(' '));
		if (tmp[0] != '/')
			return BAD_REQUEST;

		if (tmp.length() < REQUEST_URI_MAX_LENGTH)
		{
			this->target = tmp;
			if (this->target.find("?") != std::string::npos)
			{
				this->url = this->target.substr(0, this->target.find("?"));
				this->queryUrl = this->target.substr(this->target.find('?') + 1);
			}
			request.erase(0, this->target.length() + 1);
			if (!this->url.empty())
				this->target = this->url;
		}
		else
			return REQUEST_URI_TOO_LONG;

		if (request.find(' ') == 0)
			return BAD_REQUEST;
		
		size_t end = request.find("\r\n");
		tmp = request.substr(0, end);
		
		if (tmp == "HTTP/1.1")
		{
			this->protocol = tmp;
			request.erase(0, end + 2);
		}
		else
			return HTTP_VERSION_NOT_SUPPORTED;
	}
	return EXIT_SUCCESS;
}

std::string ltrim(const std::string &s)
{
	size_t start = s.find_first_not_of(" ");
	return (start == std::string::npos) ? "" : s.substr(start);
}

std::string rtrim(const std::string &s)
{
	size_t end = s.find_last_not_of(" ");
	return (end == std::string::npos) ? "" : s.substr(0, end + 1);
}

std::string trim(const std::string &s)
{
	return rtrim(ltrim(s));
}

int		Request::request_headers()
{
	 size_t header_end, header_dil;
	 std::string header;
	 std::string value;

	while ((header_end = this->request.find("\r\n")) != std::string::npos)
	{
		std::string tmp = this->request.substr(0, header_end);
		if (header_end == 0)
		{
			this->request.erase(0, 2);
			break;
		}
		if ((header_dil = tmp.find(':', 0)) != std::string::npos)
		{
			if (header_dil == 0 || tmp[header_dil - 1] == ' ')
			 	return BAD_REQUEST;
			header = tmp.substr(0, header_dil);
			value = tmp.substr(header_dil + 1, header_end - header_dil - 1);
			if (tmp == "Host" && this->headers.count(header))
				return BAD_REQUEST;
			if (header.length() > HEADER_MAX_LENGTH || value.length() > VALUE_MAX_LENGTH)
				return BAD_REQUEST;
			this->headers[header] = trim(value);
		}
		else
		 	return BAD_REQUEST;
		request.erase(0, header_end + 2);
		tmp.clear();
	}
	return EXIT_SUCCESS;
}

int		Request::request_body()
{
	if (this->headers["Content-Type"].find("boundary") != std::string::npos && this->request.find("filename=") == std::string::npos)
	{
		if (this->request.find("Content-Disposition") != std::string::npos)
		{
			this->request.erase(0, request.find("Content-Disposition") + 21);
			ContentDiposition = this->request.substr(0,request.find(";"));
			this->headers["Content-Disposition"] = ContentDiposition;
			this->request.erase(0,request.find(";") + 1);
		}
		if (this->request.find("name") != std::string::npos)
		{
			this->name = this->request.erase(0, request.find("=")).substr(2, request.find("\r\n") - 3);
			this->headers["name"] = this->name;
			this->request.erase(0, request.find("\r\n") + 4);
		}
		if (this->request[0] != '-')
		{
			this->value = this->request.substr(0, request.find("-"));
			this->headers["value"] = this->value;
		}

	}
	else if (this->headers["Content-Type"].find("boundary") != std::string::npos && this->request.find("filename=") != std::string::npos)
	{
		if (this->request.find("Content-Disposition") != std::string::npos)
		{
			this->request.erase(0, request.find("Content-Disposition") + 21);
			ContentDiposition = this->request.substr(0,request.find(";"));
			this->headers["Content-Disposition"] = ContentDiposition;
			this->request.erase(0,request.find(";") + 1);
			this->request.erase(0,request.find(";") + 2);
		}
		if (this->request.find("filename") != std::string::npos)
		{
			this->request.erase(0, request.find("\"") + 1);
			this->name = this->request.substr(0, request.find("\""));
			this->headers["name"] = this->name;
			this->request.erase(0, request.find("\r\n") + 2);
		}
		if (this->request.find("Content-Type") != std::string::npos)
		{
			this->request.erase(0, request.find(":") + 2);
			this->contentType = this->request.substr(0, request.find("\r\n"));
			this->headers["ContentType"] = this->contentType;
			this->request.erase(0, request.find("\r\n\r\n") + 4);
			std::cout << this->request << std::endl;
		}
		this->value = this->request.substr(0, request.find("-") - 2);
		this->headers["value"] = this->value;
	}
	else
	{
		if (this->request.find("\n") == std::string::npos)
		{
			this->body = this->request;
		}
		else
		{
			while (this->request.length())
			{	
				std::string tmp = this->request.substr(0, this->request.find("\n"));
				std::cout << "tmp: " << tmp << std::endl;
				if (tmp[tmp.size() - 1] == '\r')
    				tmp.erase(tmp.size() - 1);
				this->body.append(tmp);
				this->request.erase(0, this->request.find("\n") + 1);	
			}
		}
	}
	return EXIT_SUCCESS;
}

std::string &Request::getTarget()
{
	if (this->target[0] != '/')
		this->target = "/" + this->target;
	return (this->target);
}

int		&Request::getPort()
{
	std::string tmp;
	for (std::map<std::string, std::string>::iterator it = this->headers.begin(); it != this->headers.end(); it++)
		if (it->first == "Host")
			tmp = it->second;
	if (tmp.find(":") != std::string::npos)
	{
		tmp.erase(0, tmp.find(":") + 1);
		this->port = atoi(tmp.c_str());
	}
	else
		this->port = 80;
	
	return this->port;
}

std::string &Request::getProtocol()
{
	return (this->protocol);
}

std::string Request::getMethod()
{
	return (this->Method);
}

void Request::reset()
{
	this->Method.clear();
    this->target.clear();
    this->protocol.clear();
    this->headers.clear();
    this->queryUrl.clear();
    this->url.clear();
}

std::string Request::getQueryString() const {
    return this->queryUrl;
}

std::string Request::getReqValue(const std::string& key) const {
    // Comprueba si la clave existe en el mapa de encabezados
    if (this->headers.find(key) != this->headers.end()) {
        // Si la clave existe, devuelve el valor asociado
        return this->headers.at(key);
    } else {
        // Si la clave no existe, devuelve una cadena vacía
        return "";
    }
}

  -Archivo Request.hpp:
#ifndef REQUEST_HPP
#define REQUEST_HPP

#define REQUEST_URI_MAX_LENGTH 2048
#define HEADER_MAX_LENGTH 1000
#define VALUE_MAX_LENGTH 4000

//  Information 1xx
#define CONTINUE 100
#define SWITCHING_PROTOCOL 101

// Successful 2xx
#define OK 200
#define CREATED 201
#define ACCEPTED 202
#define NON_AUTHORITATIVE 203
#define NO_CONTENT 204
#define RESET_CONTENT 205
#define PARTIAL_CONTENT 206

// Redirection 3xx
#define MULTIPLE_CHOICES 300
#define MOVED_PERMANENTLY 301
#define FOUND 302
#define SEE_OTHER 303
#define NOT_MODIFIED 304
#define USE_PROXY 305

// Client Error 4xx
#define BAD_REQUEST 400
#define UNAUTHORIZED 401
#define PAYMENT_REQUIRED 402
#define FORBIDEN 403
#define NOT_FOUND 404
#define METHOD_NOT_ALLOWED 405
#define NOT_ACCEPTABLE 406
#define PROXY_AUTHENTCATION_REQUIRED 407
#define REQUEST_TIMEOUT 408
#define CONFLICT 409
#define GONE 410
#define LENGTH_REQUIRED 411
#define PRECONDITION_FAILED 412
#define REQUEST_ENTITY_TOO_LARGE 413
#define REQUEST_URI_TOO_LONG 414
#define UNSUPPORTED_MEDIA_TYPE 415
#define REQUEST_RANGE_NOT_SATISFIABLE 416
#define EXPECTATION_FAILED 417

// Server Error 5xx
#define INTERNAL_SERVER_ERROR 500
#define NOT_IMPLEMENTED 501
#define BAD_GETEWAY 502
#define SERVICE_UNABAILABLE 503
#define GATEWAY_TIMEOUT 504
#define HTTP_VERSION_NOT_SUPPORTED 505

#include <string>
#include <iostream>
#include <map>
#include <string.h>
#include <stdlib.h>

class Request
{
    private:
        std::string request;
        std::string Method;
        std::string target;
        std::string queryUrl;
        std::string url;
        std::string protocol;
        std::string body;
        std::map<std::string, std::string> headers;
        int			port;
        int         _statusCode;
        std::string ContentDiposition;
        std::string name;
        std::string value;

        std::string contentType;
    public:
        Request();
        ~Request();
        int		Request_start(std::string request);
        int     request_line();
        int     request_headers();
        int     request_body();
        void    printRequestInformation();
        void    reset();
        std::string &getTarget();
        int     &getPort();
        std::string &getProtocol();
        std::string getMethod();
        std::string getQueryString() const; // nuevo método
        std::string getReqValue(const std::string& key) const; // nuevo método
};

#endif

Archivos de Server:
  -Server.cpp:
#include "Server.hpp"

Server::Server(Config config, std::string configFile) : _masterSockFD(0),
				   _port(0),
				   _host(""),
				   _addrLen(0),
				   _maxSockFD(0)
{
				   this->servers_parsed = config.parseConfig(configFile);
				   this->makeSockets();
				   this->waitingForConnections();
}

Server::Server(std::vector<Config> &servers) : servers_parsed(servers),
												   _masterSockFD(0),
												   _port(0),
												   _host(""),
												   _addrLen(0),
												   _maxSockFD(0)
{
	this->makeSockets();
	this->waitingForConnections();
}

Server::Server(Server const &ths)
{
	*this = ths;
	return;
}

Server::~Server()
{
	servers_parsed.clear();
	_masterSockFDs.clear();
	_ports.clear();
	_clients.clear();
	_accptMaster.clear();
}

// Assignment operator=
Server &Server::operator=(Server const &ths)
{
	if (this != &ths)
	{
		this->servers_parsed = ths.servers_parsed;
		this->_masterSockFDs = ths._masterSockFDs;
		this->_masterSockFD = ths._masterSockFD;
		this->_ports = ths._ports;
		this->_port = ths._port;
		this->_host = ths._host;
		this->_serverAddr = ths._serverAddr;
		this->_clientAddr = ths._clientAddr;
		this->_addrLen = ths._addrLen;
		this->_masterFDs = ths._masterFDs;
		this->_readFDs = ths._readFDs;
		this->_writeFDs = ths._writeFDs;
		this->_maxSockFD = ths._maxSockFD;
		this->_clients = ths._clients;
		this->_accptMaster = ths._accptMaster;
	}
	return *this;
}

void Server::makeSockets()
{
	FD_ZERO(&_masterFDs);
	FD_ZERO(&_writeFDs);
	FD_SET(STDIN_FILENO, &_masterFDs);
	for (std::vector<Config>::iterator itServer = servers_parsed.begin(); itServer != servers_parsed.end(); itServer++)
	{
		std::cout << "============================================" << std::endl;
		std::cout << "Esta entrando en el servidor-> "<< itServer->getIndex() << std::endl;
		_port = itServer->getPort();
		std::cout << "EL PUERTO ES: " << _port << std::endl;
		_host = itServer->getHost();
		std::cout << "EL HOST ES: " << _host << std::endl;
			try
			{
				this->createSocket();	
				this->bindSocket();
				this->listenSocket();
			}
			catch (const std::exception &e)
			{
				close(_masterSockFD);
				std::cerr << e.what() << '\n';
			}
	}
}

void Server::createSocket()
{
	if ((_masterSockFD = socket(AF_INET, SOCK_STREAM, 0)) == -1)
		throw std::runtime_error("Unable to create a socket.");
	if (fcntl(_masterSockFD, F_SETFL, O_NONBLOCK) == -1)
		throw std::runtime_error("Unable to set the socket  /*(+ std::wstring(_masterSockFD) +*/  to non-blocking.");
	int opt = 1;
	if (setsockopt(_masterSockFD, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int)) == -1)
		throw std::runtime_error("Unable to set socket option to the socket" /* + std::wstring(_masterSockFD)*/);
}

void Server::bindSocket()
{
	std::memset(&_serverAddr, 0, sizeof(_serverAddr));
	_addrLen = sizeof(_serverAddr);
	_serverAddr.sin_family = AF_INET;
	//Htons cambia el puerto a network byte order, en vez de host byte order
	_serverAddr.sin_port = htons(_port);
	if (_host == "ANY")
		_serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	else
		_serverAddr.sin_addr.s_addr = inet_addr(_host.c_str());
	bind(_masterSockFD, (struct sockaddr *)&_serverAddr, sizeof(_serverAddr));
}

void Server::listenSocket()
{
	if (listen(_masterSockFD, BACKLOG) == -1)
		throw std::runtime_error("Unable to listen for connections in the socket ");
	FD_SET(_masterSockFD, &_masterFDs);
	if (_masterSockFD > _maxSockFD)
	{
		_maxSockFD = _masterSockFD;
	}
	_masterSockFDs.push_back(_masterSockFD);
}

void Server::waitingForConnections()
{
	int running = 1;
	std::cout << BLUE <<"\t<Server running... waiting for connections./>" << RESET << std::endl;
	while (running)
	{
		FD_ZERO(&_readFDs);
		_readFDs = _masterFDs;
		usleep(2000);
		struct timeval _tv = {1, 0};
		int activity = select(_maxSockFD + 1, &_readFDs, &_writeFDs, NULL, &_tv);
		if (activity == -1)
		{
			std::cout << RED << "Select failed to multiplexing Input/Output." << RESET << std::endl;
			break;
		}
		if (activity > 0)
		{
			if (FD_ISSET(0, &_readFDs))
			{
				std::cout << BLUE << "Shutting down server gracefuly" << RESET << std::endl;
				running = 0;
				for (std::vector<int>::iterator it = _masterSockFDs.begin(); it != _masterSockFDs.end(); it++)
				{
					close(*it);
				}
				FD_ZERO(&_masterFDs);
				FD_ZERO(&_readFDs);
				FD_ZERO(&_writeFDs);
				break;
			}
			for (int sockFD = 1; sockFD < _maxSockFD + 1; sockFD++)
			{
				if (FD_ISSET(sockFD, &_readFDs))
				{
					int newConnect = 0;
					for (std::vector<int>::iterator it = _masterSockFDs.begin(); it != _masterSockFDs.end(); it++)
					{
						if (sockFD == *it)
						{
							newConnect = 1;
							break;
						}
					}
					if (newConnect)
						this->newConnectHandling(sockFD);
					else
						this->acceptedConnectHandling(sockFD);
				}
			}
		}
	}
}

void Server::newConnectHandling(int &sockFD)
{
	int accptSockFD = accept(sockFD, (struct sockaddr *)&_clientAddr, &_addrLen);
	if (accptSockFD == -1)
		throw std::runtime_error("Unable to accept the connection from client by the socket ");
	if (fcntl(accptSockFD, F_SETFL, O_NONBLOCK) == -1)
		throw std::runtime_error("Unable to set the socket to non-blocking.");
	FD_SET(accptSockFD, &_masterFDs);
	FD_SET(accptSockFD, &_writeFDs);
	if (accptSockFD > _maxSockFD)
		_maxSockFD = accptSockFD;
	_clients.insert(std::pair<int, std::string>(accptSockFD, ""));
	std::map<int, int>::iterator it = _accptMaster.find(accptSockFD);
	if (it != _accptMaster.end())
		it->second = sockFD;
	else
		_accptMaster.insert(std::pair<int, int>(accptSockFD, sockFD));
}

void Server::acceptedConnectHandling(int &accptSockFD)
{
	char buffer[BUFFER_SIZE + 1] = {0};
	bzero(buffer, sizeof(buffer));
	int valRead = recv(accptSockFD, buffer, BUFFER_SIZE, 0);
	if (valRead > 0)
	{
		buffer[valRead] = '\0';
		std::map<int, std::string>::iterator it = _clients.find(accptSockFD);
		if (it != _clients.end())
			it->second += buffer;
		std::string req(buffer);
		this->_request.reset();
		this->_request.Request_start(req);
		if (FD_ISSET(accptSockFD, &_writeFDs))
		{
			std::cout << runCGI(this->_request, "./cgi", "./cgi/cgiscript.py") << std::endl;
			this->responseHandling(accptSockFD);
		}
	}
	if (valRead == 0)
	{
		close(accptSockFD);
		FD_CLR(accptSockFD, &_masterFDs);
		FD_CLR(accptSockFD, &_writeFDs);
		_clients.erase(accptSockFD);
	}
	else
		return; // Socket is connected but doesn't send request.
}


#include "../response/Response.hpp"

void Server::responseHandling(int &accptSockFD)
{
	std::string body;
	std::string path = _request.getTarget().erase(0, 1);
	//char *header = strdup("HTTP/1.1 200 OK\r\nContent-Length: ");

	Response _resp;
	_resp.responseCreation(this->servers_parsed, this->_request);
	// this->_request.clear();

	//std::string all = std::string(header) + std::string(ft_itoa(_resp.GetBody().size())) + "\r\n\r\n" + _resp.GetBody();

	if (FD_ISSET(accptSockFD, &_writeFDs))
	{
		std::cout << "something with the socket" << std::endl;
		//if (send)
	// 	if () // if connection is set to close in request close
	// 	{
	// 		close(accptSockFD);
	// 		FD_CLR(accptSockFD, &_masterFDs);
	// 		FD_CLR(accptSockFD, &_writeFDs);
	// 	}
	}
	// _resp.clear();
	// this->_request.clear();
}

  -Archivo Server.hpp:
#ifndef SERVER_HPP
#define SERVER_HPP

#define RED "\033[31m"
#define GREEN "\033[32m"
#define YELLOW "\033[33m"
#define BLUE "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN "\033[36m"
#define RESET "\033[0m"

#include "../Webserv.hpp"
#include "../config/Config.hpp"
#include "../request/Request.hpp"
#include <cstring>
#include <string>
#include <arpa/inet.h>
#include <fcntl.h>
#include <vector>
#include <map>
#include <sys/socket.h> //listen, recv
#include <sys/select.h> //select
#include <sys/types.h>
#include <utility>

// #include <iostream>
// #include <netinet/in.h>
// #include <fstream>
// #include <unistd.h>
// #include <sys/stat.h>
// #include <algorithm>
// #include <sstream>

#define BUFFER_SIZE 1024	
#define BACKLOG 2048

class Config;
class Request;
class Response;

class Server
{
    private:
        std::vector<Config> servers_parsed;
        Request _request;
	    // Making sockets
	    int _masterSockFD;
	    std::vector<int> _masterSockFDs;
	    std::vector<int> _ports;
	    int _port;
	    std::string _host;

	    // Socket infos
	    struct sockaddr_in _serverAddr;
	    struct sockaddr_in _clientAddr;
	    socklen_t _addrLen;

	    // fd_set structures select()
	    fd_set _masterFDs;
	    fd_set _readFDs;
	    fd_set _writeFDs;

	    // Max of fds
	    int _maxSockFD;

	    // Clients sockets data request will hold by second element
	    std::map<int, std::string> _clients;

	    // first is accept socket ; second is master socket
	    std::map<int, int> _accptMaster;

	    // HttpServer _server;
	    //int _isvalid;

    public:
	    Server(Config config, std::string configFile);
	    Server(std::vector<Config> &);
	    Server(Server const &);
	    ~Server();
	    Server &operator=(const Server &);
	    std::string get_body(std::string file_name);
	    char *ft_itoa(int n);
	    static int num_len(int n);
	    void makeSockets();
	    void createSocket();
	    void bindSocket();
	    void listenSocket();
	    void waitingForConnections();
	    void newConnectHandling(int &);
	    void acceptedConnectHandling(int &);
	    void responseHandling(int &);
};

#endif

Archivo del ".hpp" principal:
  -Archivo webserver.hpp:
  #ifndef WEBSERV_HPP
#define WEBSERV_HPP

#include "./server/Server.hpp"
#include "./config/Config.hpp"
#include "./config/Location.hpp"
#include "./request/Request.hpp"
#include "./cgi/cgi.hpp"

//Aqui van todos los includes que se usaran en el proyecto, en los archivos incluimos Webserv.hpp y ya.
//La configuración va a ser una clase, el servidor va a ser una clase, el request y la respuesta tambien van a ser una clase.
//La configuración despues de parsear va a ser una clase donde esten puestos todos los flags dentro de los attributos de la clase para que el servidor sepa que tiene que hacer

#include <sys/socket.h> // For socket functions
#include <netinet/in.h> // For sockaddr_in
#include <cstdlib> // For exit() and EXIT_FAILURE
#include <iostream> // For cout
#include <unistd.h> // For read
#include <cerrno>
#include <vector> // Include the necessary header file
#include <string>

#endif

Archivo del Main:
  -Archivo Main.cpp:
#include "Webserv.hpp"
#include "./request/Request.hpp"
#include "./parseo_conf/include.hpp"

int main(int ac, char **av)
{
	if (ac != 2)
  	{
    	std::cout << "Usage: " << av[0] << " <config file>" << std::endl;
    	return 1;
  	}
	verifyConf(av[1]);
	std::string confFilename;
	Config config;
	confFilename = av[1];

	Server server(config, confFilename);
	return 0;
}
